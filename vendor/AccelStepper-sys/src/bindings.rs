/* automatically generated by rust-bindgen */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type boolean = bool;
#[repr(C)]
pub struct AccelStepper__bindgen_vtable(::std::os::raw::c_void);
#[doc = ""]
#[doc = " \\class AccelStepper AccelStepper.h <AccelStepper.h>"]
#[doc = " \\brief Support for stepper motors with acceleration etc."]
#[doc = ""]
#[doc = " This defines a single 2 or 4 pin stepper motor, or stepper moter with fdriver chip, with optional"]
#[doc = " acceleration, deceleration, absolute positioning commands etc. Multiple"]
#[doc = " simultaneous steppers are supported, all moving"]
#[doc = " at different speeds and accelerations."]
#[doc = ""]
#[doc = " \\par Operation"]
#[doc = " This module operates by computing a step time in microseconds. The step"]
#[doc = " time is recomputed after each step and after speed and acceleration"]
#[doc = " parameters are changed by the caller. The time of each step is recorded in"]
#[doc = " microseconds. The run() function steps the motor once if a new step is due."]
#[doc = " The run() function must be called frequently until the motor is in the"]
#[doc = " desired position, after which time run() will do nothing."]
#[doc = ""]
#[doc = " \\par Positioning"]
#[doc = " Positions are specified by a signed long integer. At"]
#[doc = " construction time, the current position of the motor is consider to be 0. Positive"]
#[doc = " positions are clockwise from the initial position; negative positions are"]
#[doc = " anticlockwise. The current position can be altered for instance after"]
#[doc = " initialization positioning."]
#[doc = ""]
#[doc = " \\par Caveats"]
#[doc = " This is an open loop controller: If the motor stalls or is oversped,"]
#[doc = " AccelStepper will not have a correct"]
#[doc = " idea of where the motor really is (since there is no feedback of the motor's"]
#[doc = " real position. We only know where we _think_ it is, relative to the"]
#[doc = " initial starting point)."]
#[doc = ""]
#[doc = " \\par Performance"]
#[doc = " The fastest motor speed that can be reliably supported is about 4000 steps per"]
#[doc = " second at a clock frequency of 16 MHz on Arduino such as Uno etc."]
#[doc = " Faster processors can support faster stepping speeds."]
#[doc = " However, any speed less than that"]
#[doc = " down to very slow speeds (much less than one per second) are also supported,"]
#[doc = " provided the run() function is called frequently enough to step the motor"]
#[doc = " whenever required for the speed set."]
#[doc = " Calling setAcceleration() is expensive,"]
#[doc = " since it requires a square root to be calculated."]
#[doc = ""]
#[doc = " Gregor Christandl reports that with an Arduino Due and a simple test program,"]
#[doc = " he measured 43163 steps per second using runSpeed(),"]
#[doc = " and 16214 steps per second using run();"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelStepper {
    pub vtable_: *const AccelStepper__bindgen_vtable,
    #[doc = " Current direction motor is spinning in"]
    #[doc = " Protected because some peoples subclasses need it to be so"]
    pub _direction: boolean,
    #[doc = " Number of pins on the stepper motor. Permits 2 or 4. 2 pins is a"]
    #[doc = " bipolar, and 4 pins is a unipolar."]
    pub _interface: u8,
    #[doc = " Arduino pin number assignments for the 2 or 4 pins required to interface to the"]
    #[doc = " stepper motor or driver"]
    pub _pin: [u8; 4usize],
    #[doc = " Whether the _pins is inverted or not"]
    pub _pinInverted: [u8; 4usize],
    #[doc = " The current absolution position in steps."]
    pub _currentPos: ::std::os::raw::c_long,
    #[doc = " The target position in steps. The AccelStepper library will move the"]
    #[doc = " motor from the _currentPos to the _targetPos, taking into account the"]
    #[doc = " max speed, acceleration and deceleration"]
    pub _targetPos: ::std::os::raw::c_long,
    #[doc = " The current motos speed in steps per second"]
    #[doc = " Positive is clockwise"]
    pub _speed: f32,
    #[doc = " The maximum permitted speed in steps per second. Must be > 0."]
    pub _maxSpeed: f32,
    #[doc = " The acceleration to use to accelerate or decelerate the motor in steps"]
    #[doc = " per second per second. Must be > 0"]
    pub _acceleration: f32,
    pub _sqrt_twoa: f32,
    #[doc = " The current interval between steps in microseconds."]
    #[doc = " 0 means the motor is currently stopped with _speed == 0"]
    pub _stepInterval: ::std::os::raw::c_ulong,
    #[doc = " The last step time in microseconds"]
    pub _lastStepTime: ::std::os::raw::c_ulong,
    #[doc = " The minimum allowed pulse width in microseconds"]
    pub _minPulseWidth: ::std::os::raw::c_uint,
    #[doc = " Is the enable pin inverted?"]
    pub _enableInverted: bool,
    #[doc = " Enable pin for stepper driver, or 0xFF if unused."]
    pub _enablePin: u8,
    #[doc = " The pointer to a forward-step procedure"]
    pub _forward: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " The pointer to a backward-step procedure"]
    pub _backward: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " The step counter for speed calculations"]
    pub _n: ::std::os::raw::c_long,
    #[doc = " Initial step size in microseconds"]
    pub _c0: f32,
    #[doc = " Last step size in microseconds"]
    pub _cn: f32,
    #[doc = " Min step size in microseconds based on maxSpeed"]
    pub _cmin: f32,
}
#[doc = "< Use the functional interface, implementing your own driver functions (internal use only)"]
pub const AccelStepper_MotorInterfaceType_FUNCTION: AccelStepper_MotorInterfaceType = 0;
#[doc = "< Stepper Driver, 2 driver pins required"]
pub const AccelStepper_MotorInterfaceType_DRIVER: AccelStepper_MotorInterfaceType = 1;
#[doc = "< 2 wire stepper, 2 motor pins required"]
pub const AccelStepper_MotorInterfaceType_FULL2WIRE: AccelStepper_MotorInterfaceType = 2;
#[doc = "< 3 wire stepper, such as HDD spindle, 3 motor pins required"]
pub const AccelStepper_MotorInterfaceType_FULL3WIRE: AccelStepper_MotorInterfaceType = 3;
#[doc = "< 4 wire full stepper, 4 motor pins required"]
pub const AccelStepper_MotorInterfaceType_FULL4WIRE: AccelStepper_MotorInterfaceType = 4;
#[doc = "< 3 wire half stepper, such as HDD spindle, 3 motor pins required"]
pub const AccelStepper_MotorInterfaceType_HALF3WIRE: AccelStepper_MotorInterfaceType = 6;
#[doc = "< 4 wire half stepper, 4 motor pins required"]
pub const AccelStepper_MotorInterfaceType_HALF4WIRE: AccelStepper_MotorInterfaceType = 8;
#[doc = " \\brief Symbolic names for number of pins."]
#[doc = " Use this in the pins argument the AccelStepper constructor to"]
#[doc = " provide a symbolic name for the number of pins"]
#[doc = " to use."]
pub type AccelStepper_MotorInterfaceType = u32;
#[doc = "< Counter-Clockwise"]
pub const AccelStepper_Direction_DIRECTION_CCW: AccelStepper_Direction = 0;
#[doc = "< Clockwise"]
pub const AccelStepper_Direction_DIRECTION_CW: AccelStepper_Direction = 1;
#[doc = " \\brief Direction indicator"]
#[doc = " Symbolic names for the direction the motor is turning"]
pub type AccelStepper_Direction = u32;
#[test]
fn bindgen_test_layout_AccelStepper() {
    assert_eq!(
        ::std::mem::size_of::<AccelStepper>(),
        120usize,
        concat!("Size of: ", stringify!(AccelStepper))
    );
    assert_eq!(
        ::std::mem::align_of::<AccelStepper>(),
        8usize,
        concat!("Alignment of ", stringify!(AccelStepper))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._direction as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._interface as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._pin as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_pin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._pinInverted as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_pinInverted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._currentPos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_currentPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._targetPos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_targetPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._speed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._maxSpeed as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_maxSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._acceleration as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_acceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._sqrt_twoa as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_sqrt_twoa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._stepInterval as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_stepInterval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._lastStepTime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_lastStepTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._minPulseWidth as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_minPulseWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._enableInverted as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_enableInverted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._enablePin as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_enablePin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._forward as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_forward)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._backward as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_backward)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._n as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._c0 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_c0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._cn as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_cn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccelStepper>()))._cmin as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AccelStepper),
            "::",
            stringify!(_cmin)
        )
    );
}
extern "C" {
    #[doc = " Set the target position. The run() function will try to move the motor (at most one step per call)"]
    #[doc = " from the current position to the target position set by the most"]
    #[doc = " recent call to this function. Caution: moveTo() also recalculates the speed for the next step."]
    #[doc = " If you are trying to use constant speed movements, you should call setSpeed() after calling moveTo()."]
    #[doc = " \\param[in] absolute The desired absolute position. Negative is"]
    #[doc = " anticlockwise from the 0 position."]
    #[link_name = "\u{1}_ZN12AccelStepper6moveToEl"]
    pub fn AccelStepper_moveTo(this: *mut AccelStepper, absolute: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Set the target position relative to the current position"]
    #[doc = " \\param[in] relative The desired position relative to the current position. Negative is"]
    #[doc = " anticlockwise from the current position."]
    #[link_name = "\u{1}_ZN12AccelStepper4moveEl"]
    pub fn AccelStepper_move(this: *mut AccelStepper, relative: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Poll the motor and step it if a step is due, implementing"]
    #[doc = " accelerations and decelerations to acheive the target position. You must call this as"]
    #[doc = " frequently as possible, but at least once per minimum step time interval,"]
    #[doc = " preferably in your main loop. Note that each call to run() will make at most one step, and then only when a step is due,"]
    #[doc = " based on the current speed and the time since the last step."]
    #[doc = " \\return true if the motor is still running to the target position."]
    #[link_name = "\u{1}_ZN12AccelStepper3runEv"]
    pub fn AccelStepper_run(this: *mut AccelStepper) -> boolean;
}
extern "C" {
    #[doc = " Poll the motor and step it if a step is due, implementing a constant"]
    #[doc = " speed as set by the most recent call to setSpeed(). You must call this as"]
    #[doc = " frequently as possible, but at least once per step interval,"]
    #[doc = " \\return true if the motor was stepped."]
    #[link_name = "\u{1}_ZN12AccelStepper8runSpeedEv"]
    pub fn AccelStepper_runSpeed(this: *mut AccelStepper) -> boolean;
}
extern "C" {
    #[doc = " Sets the maximum permitted speed. The run() function will accelerate"]
    #[doc = " up to the speed set by this function."]
    #[doc = " Caution: the maximum speed achievable depends on your processor and clock speed."]
    #[doc = " The default maxSpeed is 1.0 steps per second."]
    #[doc = " \\param[in] speed The desired maximum speed in steps per second. Must"]
    #[doc = " be > 0. Caution: Speeds that exceed the maximum speed supported by the processor may"]
    #[doc = " Result in non-linear accelerations and decelerations."]
    #[link_name = "\u{1}_ZN12AccelStepper11setMaxSpeedEf"]
    pub fn AccelStepper_setMaxSpeed(this: *mut AccelStepper, speed: f32);
}
extern "C" {
    #[doc = " returns the maximum speed configured for this stepper"]
    #[doc = " that was previously set by setMaxSpeed();"]
    #[doc = " \\return The currently configured maximum speed"]
    #[link_name = "\u{1}_ZN12AccelStepper8maxSpeedEv"]
    pub fn AccelStepper_maxSpeed(this: *mut AccelStepper) -> f32;
}
extern "C" {
    #[doc = " Sets the acceleration/deceleration rate."]
    #[doc = " \\param[in] acceleration The desired acceleration in steps per second"]
    #[doc = " per second. Must be > 0.0. This is an expensive call since it requires a square"]
    #[doc = " root to be calculated. Dont call more ofthen than needed"]
    #[link_name = "\u{1}_ZN12AccelStepper15setAccelerationEf"]
    pub fn AccelStepper_setAcceleration(this: *mut AccelStepper, acceleration: f32);
}
extern "C" {
    #[doc = " Sets the desired constant speed for use with runSpeed()."]
    #[doc = " \\param[in] speed The desired constant speed in steps per"]
    #[doc = " second. Positive is clockwise. Speeds of more than 1000 steps per"]
    #[doc = " second are unreliable. Very slow speeds may be set (eg 0.00027777 for"]
    #[doc = " once per hour, approximately. Speed accuracy depends on the Arduino"]
    #[doc = " crystal. Jitter depends on how frequently you call the runSpeed() function."]
    #[doc = " The speed will be limited by the current value of setMaxSpeed()"]
    #[link_name = "\u{1}_ZN12AccelStepper8setSpeedEf"]
    pub fn AccelStepper_setSpeed(this: *mut AccelStepper, speed: f32);
}
extern "C" {
    #[doc = " The most recently set speed"]
    #[doc = " \\return the most recent speed in steps per second"]
    #[link_name = "\u{1}_ZN12AccelStepper5speedEv"]
    pub fn AccelStepper_speed(this: *mut AccelStepper) -> f32;
}
extern "C" {
    #[doc = " The distance from the current position to the target position."]
    #[doc = " \\return the distance from the current position to the target position"]
    #[doc = " in steps. Positive is clockwise from the current position."]
    #[link_name = "\u{1}_ZN12AccelStepper12distanceToGoEv"]
    pub fn AccelStepper_distanceToGo(this: *mut AccelStepper) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " The most recently set target position."]
    #[doc = " \\return the target position"]
    #[doc = " in steps. Positive is clockwise from the 0 position."]
    #[link_name = "\u{1}_ZN12AccelStepper14targetPositionEv"]
    pub fn AccelStepper_targetPosition(this: *mut AccelStepper) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " The currently motor position."]
    #[doc = " \\return the current motor position"]
    #[doc = " in steps. Positive is clockwise from the 0 position."]
    #[link_name = "\u{1}_ZN12AccelStepper15currentPositionEv"]
    pub fn AccelStepper_currentPosition(this: *mut AccelStepper) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Resets the current position of the motor, so that wherever the motor"]
    #[doc = " happens to be right now is considered to be the new 0 position. Useful"]
    #[doc = " for setting a zero position on a stepper after an initial hardware"]
    #[doc = " positioning move."]
    #[doc = " Has the side effect of setting the current motor speed to 0."]
    #[doc = " \\param[in] position The position in steps of wherever the motor"]
    #[doc = " happens to be right now."]
    #[link_name = "\u{1}_ZN12AccelStepper18setCurrentPositionEl"]
    pub fn AccelStepper_setCurrentPosition(
        this: *mut AccelStepper,
        position: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " Moves the motor (with acceleration/deceleration)"]
    #[doc = " to the target position and blocks until it is at"]
    #[doc = " position. Dont use this in event loops, since it blocks."]
    #[link_name = "\u{1}_ZN12AccelStepper13runToPositionEv"]
    pub fn AccelStepper_runToPosition(this: *mut AccelStepper);
}
extern "C" {
    #[doc = " Runs at the currently selected speed until the target position is reached"]
    #[doc = " Does not implement accelerations."]
    #[doc = " \\return true if it stepped"]
    #[link_name = "\u{1}_ZN12AccelStepper18runSpeedToPositionEv"]
    pub fn AccelStepper_runSpeedToPosition(this: *mut AccelStepper) -> boolean;
}
extern "C" {
    #[doc = " Moves the motor (with acceleration/deceleration)"]
    #[doc = " to the new target position and blocks until it is at"]
    #[doc = " position. Dont use this in event loops, since it blocks."]
    #[doc = " \\param[in] position The new target position."]
    #[link_name = "\u{1}_ZN12AccelStepper16runToNewPositionEl"]
    pub fn AccelStepper_runToNewPosition(this: *mut AccelStepper, position: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Sets a new target position that causes the stepper"]
    #[doc = " to stop as quickly as possible, using the current speed and acceleration parameters."]
    #[link_name = "\u{1}_ZN12AccelStepper4stopEv"]
    pub fn AccelStepper_stop(this: *mut AccelStepper);
}
extern "C" {
    #[doc = " Sets the minimum pulse width allowed by the stepper driver. The minimum practical pulse width is"]
    #[doc = " approximately 20 microseconds. Times less than 20 microseconds"]
    #[doc = " will usually result in 20 microseconds or so."]
    #[doc = " \\param[in] minWidth The minimum pulse width in microseconds."]
    #[link_name = "\u{1}_ZN12AccelStepper16setMinPulseWidthEj"]
    pub fn AccelStepper_setMinPulseWidth(this: *mut AccelStepper, minWidth: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Sets the enable pin number for stepper drivers."]
    #[doc = " 0xFF indicates unused (default)."]
    #[doc = " Otherwise, if a pin is set, the pin will be turned on when"]
    #[doc = " enableOutputs() is called and switched off when disableOutputs()"]
    #[doc = " is called."]
    #[doc = " \\param[in] enablePin Arduino digital pin number for motor enable"]
    #[doc = " \\sa setPinsInverted"]
    #[link_name = "\u{1}_ZN12AccelStepper12setEnablePinEh"]
    pub fn AccelStepper_setEnablePin(this: *mut AccelStepper, enablePin: u8);
}
extern "C" {
    #[doc = " Sets the inversion for stepper driver pins"]
    #[doc = " \\param[in] directionInvert True for inverted direction pin, false for non-inverted"]
    #[doc = " \\param[in] stepInvert      True for inverted step pin, false for non-inverted"]
    #[doc = " \\param[in] enableInvert    True for inverted enable pin, false (default) for non-inverted"]
    #[link_name = "\u{1}_ZN12AccelStepper15setPinsInvertedEbbb"]
    pub fn AccelStepper_setPinsInverted(
        this: *mut AccelStepper,
        directionInvert: bool,
        stepInvert: bool,
        enableInvert: bool,
    );
}
extern "C" {
    #[doc = " Sets the inversion for 2, 3 and 4 wire stepper pins"]
    #[doc = " \\param[in] pin1Invert True for inverted pin1, false for non-inverted"]
    #[doc = " \\param[in] pin2Invert True for inverted pin2, false for non-inverted"]
    #[doc = " \\param[in] pin3Invert True for inverted pin3, false for non-inverted"]
    #[doc = " \\param[in] pin4Invert True for inverted pin4, false for non-inverted"]
    #[doc = " \\param[in] enableInvert    True for inverted enable pin, false (default) for non-inverted"]
    #[link_name = "\u{1}_ZN12AccelStepper15setPinsInvertedEbbbbb"]
    pub fn AccelStepper_setPinsInverted1(
        this: *mut AccelStepper,
        pin1Invert: bool,
        pin2Invert: bool,
        pin3Invert: bool,
        pin4Invert: bool,
        enableInvert: bool,
    );
}
extern "C" {
    #[doc = " Checks to see if the motor is currently running to a target"]
    #[doc = " \\return true if the speed is not zero or not at the target position"]
    #[link_name = "\u{1}_ZN12AccelStepper9isRunningEv"]
    pub fn AccelStepper_isRunning(this: *mut AccelStepper) -> bool;
}
extern "C" {
    #[doc = " Forces the library to compute a new instantaneous speed and set that as"]
    #[doc = " the current speed. It is called by"]
    #[doc = " the library:"]
    #[doc = " \\li  after each step"]
    #[doc = " \\li  after change to maxSpeed through setMaxSpeed()"]
    #[doc = " \\li  after change to acceleration through setAcceleration()"]
    #[doc = " \\li  after change to target position (relative or absolute) through"]
    #[doc = " move() or moveTo()"]
    #[link_name = "\u{1}_ZN12AccelStepper15computeNewSpeedEv"]
    pub fn AccelStepper_computeNewSpeed(this: *mut AccelStepper);
}
extern "C" {
    #[doc = " Constructor. You can have multiple simultaneous steppers, all moving"]
    #[doc = " at different speeds and accelerations, provided you call their run()"]
    #[doc = " functions at frequent enough intervals. Current Position is set to 0, target"]
    #[doc = " position is set to 0. MaxSpeed and Acceleration default to 1.0."]
    #[doc = " The motor pins will be initialised to OUTPUT mode during the"]
    #[doc = " constructor by a call to enableOutputs()."]
    #[doc = " \\param[in] interface Number of pins to interface to. Integer values are"]
    #[doc = " supported, but it is preferred to use the \\ref MotorInterfaceType symbolic names."]
    #[doc = " AccelStepper::DRIVER (1) means a stepper driver (with Step and Direction pins)."]
    #[doc = " If an enable line is also needed, call setEnablePin() after construction."]
    #[doc = " You may also invert the pins using setPinsInverted()."]
    #[doc = " AccelStepper::FULL2WIRE (2) means a 2 wire stepper (2 pins required)."]
    #[doc = " AccelStepper::FULL3WIRE (3) means a 3 wire stepper, such as HDD spindle (3 pins required)."]
    #[doc = " AccelStepper::FULL4WIRE (4) means a 4 wire stepper (4 pins required)."]
    #[doc = " AccelStepper::HALF3WIRE (6) means a 3 wire half stepper, such as HDD spindle (3 pins required)"]
    #[doc = " AccelStepper::HALF4WIRE (8) means a 4 wire half stepper (4 pins required)"]
    #[doc = " Defaults to AccelStepper::FULL4WIRE (4) pins."]
    #[doc = " \\param[in] pin1 Arduino digital pin number for motor pin 1. Defaults"]
    #[doc = " to pin 2. For a AccelStepper::DRIVER (interface==1),"]
    #[doc = " this is the Step input to the driver. Low to high transition means to step)"]
    #[doc = " \\param[in] pin2 Arduino digital pin number for motor pin 2. Defaults"]
    #[doc = " to pin 3. For a AccelStepper::DRIVER (interface==1),"]
    #[doc = " this is the Direction input the driver. High means forward."]
    #[doc = " \\param[in] pin3 Arduino digital pin number for motor pin 3. Defaults"]
    #[doc = " to pin 4."]
    #[doc = " \\param[in] pin4 Arduino digital pin number for motor pin 4. Defaults"]
    #[doc = " to pin 5."]
    #[doc = " \\param[in] enable If this is true (the default), enableOutputs() will be called to enable"]
    #[doc = " the output pins at construction time."]
    #[link_name = "\u{1}_ZN12AccelStepperC1Ehhhhhb"]
    pub fn AccelStepper_AccelStepper(
        this: *mut AccelStepper,
        interface: u8,
        pin1: u8,
        pin2: u8,
        pin3: u8,
        pin4: u8,
        enable: bool,
    );
}
extern "C" {
    #[doc = " Alternate Constructor which will call your own functions for forward and backward steps."]
    #[doc = " You can have multiple simultaneous steppers, all moving"]
    #[doc = " at different speeds and accelerations, provided you call their run()"]
    #[doc = " functions at frequent enough intervals. Current Position is set to 0, target"]
    #[doc = " position is set to 0. MaxSpeed and Acceleration default to 1.0."]
    #[doc = " Any motor initialization should happen before hand, no pins are used or initialized."]
    #[doc = " \\param[in] forward void-returning procedure that will make a forward step"]
    #[doc = " \\param[in] backward void-returning procedure that will make a backward step"]
    #[link_name = "\u{1}_ZN12AccelStepperC1EPFvvES1_"]
    pub fn AccelStepper_AccelStepper1(
        this: *mut AccelStepper,
        forward: ::std::option::Option<unsafe extern "C" fn()>,
        backward: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
impl AccelStepper {
    #[inline]
    pub unsafe fn moveTo(&mut self, absolute: ::std::os::raw::c_long) {
        AccelStepper_moveTo(self, absolute)
    }
    #[inline]
    pub unsafe fn move_(&mut self, relative: ::std::os::raw::c_long) {
        AccelStepper_move(self, relative)
    }
    #[inline]
    pub unsafe fn run(&mut self) -> boolean {
        AccelStepper_run(self)
    }
    #[inline]
    pub unsafe fn runSpeed(&mut self) -> boolean {
        AccelStepper_runSpeed(self)
    }
    #[inline]
    pub unsafe fn setMaxSpeed(&mut self, speed: f32) {
        AccelStepper_setMaxSpeed(self, speed)
    }
    #[inline]
    pub unsafe fn maxSpeed(&mut self) -> f32 {
        AccelStepper_maxSpeed(self)
    }
    #[inline]
    pub unsafe fn setAcceleration(&mut self, acceleration: f32) {
        AccelStepper_setAcceleration(self, acceleration)
    }
    #[inline]
    pub unsafe fn setSpeed(&mut self, speed: f32) {
        AccelStepper_setSpeed(self, speed)
    }
    #[inline]
    pub unsafe fn speed(&mut self) -> f32 {
        AccelStepper_speed(self)
    }
    #[inline]
    pub unsafe fn distanceToGo(&mut self) -> ::std::os::raw::c_long {
        AccelStepper_distanceToGo(self)
    }
    #[inline]
    pub unsafe fn targetPosition(&mut self) -> ::std::os::raw::c_long {
        AccelStepper_targetPosition(self)
    }
    #[inline]
    pub unsafe fn currentPosition(&mut self) -> ::std::os::raw::c_long {
        AccelStepper_currentPosition(self)
    }
    #[inline]
    pub unsafe fn setCurrentPosition(&mut self, position: ::std::os::raw::c_long) {
        AccelStepper_setCurrentPosition(self, position)
    }
    #[inline]
    pub unsafe fn runToPosition(&mut self) {
        AccelStepper_runToPosition(self)
    }
    #[inline]
    pub unsafe fn runSpeedToPosition(&mut self) -> boolean {
        AccelStepper_runSpeedToPosition(self)
    }
    #[inline]
    pub unsafe fn runToNewPosition(&mut self, position: ::std::os::raw::c_long) {
        AccelStepper_runToNewPosition(self, position)
    }
    #[inline]
    pub unsafe fn stop(&mut self) {
        AccelStepper_stop(self)
    }
    #[inline]
    pub unsafe fn setMinPulseWidth(&mut self, minWidth: ::std::os::raw::c_uint) {
        AccelStepper_setMinPulseWidth(self, minWidth)
    }
    #[inline]
    pub unsafe fn setEnablePin(&mut self, enablePin: u8) {
        AccelStepper_setEnablePin(self, enablePin)
    }
    #[inline]
    pub unsafe fn setPinsInverted(
        &mut self,
        directionInvert: bool,
        stepInvert: bool,
        enableInvert: bool,
    ) {
        AccelStepper_setPinsInverted(self, directionInvert, stepInvert, enableInvert)
    }
    #[inline]
    pub unsafe fn setPinsInverted1(
        &mut self,
        pin1Invert: bool,
        pin2Invert: bool,
        pin3Invert: bool,
        pin4Invert: bool,
        enableInvert: bool,
    ) {
        AccelStepper_setPinsInverted1(
            self,
            pin1Invert,
            pin2Invert,
            pin3Invert,
            pin4Invert,
            enableInvert,
        )
    }
    #[inline]
    pub unsafe fn isRunning(&mut self) -> bool {
        AccelStepper_isRunning(self)
    }
    #[inline]
    pub unsafe fn computeNewSpeed(&mut self) {
        AccelStepper_computeNewSpeed(self)
    }
    #[inline]
    pub unsafe fn new(interface: u8, pin1: u8, pin2: u8, pin3: u8, pin4: u8, enable: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        AccelStepper_AccelStepper(
            &mut __bindgen_tmp,
            interface,
            pin1,
            pin2,
            pin3,
            pin4,
            enable,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        forward: ::std::option::Option<unsafe extern "C" fn()>,
        backward: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        AccelStepper_AccelStepper1(&mut __bindgen_tmp, forward, backward);
        __bindgen_tmp
    }
}
extern "C" {
    #[doc = " Disable motor pin outputs by setting them all LOW"]
    #[doc = " Depending on the design of your electronics this may turn off"]
    #[doc = " the power to the motor coils, saving power."]
    #[doc = " This is useful to support Arduino low power modes: disable the outputs"]
    #[doc = " during sleep and then reenable with enableOutputs() before stepping"]
    #[doc = " again."]
    #[doc = " If the enable Pin is defined, sets it to OUTPUT mode and clears the pin to disabled."]
    #[link_name = "\u{1}_ZN12AccelStepper14disableOutputsEv"]
    pub fn AccelStepper_disableOutputs(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Enable motor pin outputs by setting the motor pins to OUTPUT"]
    #[doc = " mode. Called automatically by the constructor."]
    #[doc = " If the enable Pin is defined, sets it to OUTPUT mode and sets the pin to enabled."]
    #[link_name = "\u{1}_ZN12AccelStepper13enableOutputsEv"]
    pub fn AccelStepper_enableOutputs(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Low level function to set the motor output pins"]
    #[doc = " bit 0 of the mask corresponds to _pin[0]"]
    #[doc = " bit 1 of the mask corresponds to _pin[1]"]
    #[doc = " You can override this to impment, for example serial chip output insted of using the"]
    #[doc = " output pins directly"]
    #[link_name = "\u{1}_ZN12AccelStepper13setOutputPinsEh"]
    pub fn AccelStepper_setOutputPins(this: *mut ::std::os::raw::c_void, mask: u8);
}
extern "C" {
    #[doc = " Called to execute a step. Only called when a new step is"]
    #[doc = " required. Subclasses may override to implement new stepping"]
    #[doc = " interfaces. The default calls step1(), step2(), step4() or step8() depending on the"]
    #[doc = " number of pins defined for the stepper."]
    #[doc = " \\param[in] step The current step phase number (0 to 7)"]
    #[link_name = "\u{1}_ZN12AccelStepper4stepEl"]
    pub fn AccelStepper_step(this: *mut ::std::os::raw::c_void, step: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Called to execute a step using stepper functions (pins = 0) Only called when a new step is"]
    #[doc = " required. Calls _forward() or _backward() to perform the step"]
    #[doc = " \\param[in] step The current step phase number (0 to 7)"]
    #[link_name = "\u{1}_ZN12AccelStepper5step0El"]
    pub fn AccelStepper_step0(this: *mut ::std::os::raw::c_void, step: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Called to execute a step on a stepper driver (ie where pins == 1). Only called when a new step is"]
    #[doc = " required. Subclasses may override to implement new stepping"]
    #[doc = " interfaces. The default sets or clears the outputs of Step pin1 to step,"]
    #[doc = " and sets the output of _pin2 to the desired direction. The Step pin (_pin1) is pulsed for 1 microsecond"]
    #[doc = " which is the minimum STEP pulse width for the 3967 driver."]
    #[doc = " \\param[in] step The current step phase number (0 to 7)"]
    #[link_name = "\u{1}_ZN12AccelStepper5step1El"]
    pub fn AccelStepper_step1(this: *mut ::std::os::raw::c_void, step: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Called to execute a step on a 2 pin motor. Only called when a new step is"]
    #[doc = " required. Subclasses may override to implement new stepping"]
    #[doc = " interfaces. The default sets or clears the outputs of pin1 and pin2"]
    #[doc = " \\param[in] step The current step phase number (0 to 7)"]
    #[link_name = "\u{1}_ZN12AccelStepper5step2El"]
    pub fn AccelStepper_step2(this: *mut ::std::os::raw::c_void, step: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Called to execute a step on a 3 pin motor, such as HDD spindle. Only called when a new step is"]
    #[doc = " required. Subclasses may override to implement new stepping"]
    #[doc = " interfaces. The default sets or clears the outputs of pin1, pin2,"]
    #[doc = " pin3"]
    #[doc = " \\param[in] step The current step phase number (0 to 7)"]
    #[link_name = "\u{1}_ZN12AccelStepper5step3El"]
    pub fn AccelStepper_step3(this: *mut ::std::os::raw::c_void, step: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Called to execute a step on a 4 pin motor. Only called when a new step is"]
    #[doc = " required. Subclasses may override to implement new stepping"]
    #[doc = " interfaces. The default sets or clears the outputs of pin1, pin2,"]
    #[doc = " pin3, pin4."]
    #[doc = " \\param[in] step The current step phase number (0 to 7)"]
    #[link_name = "\u{1}_ZN12AccelStepper5step4El"]
    pub fn AccelStepper_step4(this: *mut ::std::os::raw::c_void, step: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Called to execute a step on a 3 pin motor, such as HDD spindle. Only called when a new step is"]
    #[doc = " required. Subclasses may override to implement new stepping"]
    #[doc = " interfaces. The default sets or clears the outputs of pin1, pin2,"]
    #[doc = " pin3"]
    #[doc = " \\param[in] step The current step phase number (0 to 7)"]
    #[link_name = "\u{1}_ZN12AccelStepper5step6El"]
    pub fn AccelStepper_step6(this: *mut ::std::os::raw::c_void, step: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Called to execute a step on a 4 pin half-steper motor. Only called when a new step is"]
    #[doc = " required. Subclasses may override to implement new stepping"]
    #[doc = " interfaces. The default sets or clears the outputs of pin1, pin2,"]
    #[doc = " pin3, pin4."]
    #[doc = " \\param[in] step The current step phase number (0 to 7)"]
    #[link_name = "\u{1}_ZN12AccelStepper5step8El"]
    pub fn AccelStepper_step8(this: *mut ::std::os::raw::c_void, step: ::std::os::raw::c_long);
}
